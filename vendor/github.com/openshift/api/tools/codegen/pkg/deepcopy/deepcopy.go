package deepcopy

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"k8s.io/gengo/args"
	"k8s.io/gengo/examples/deepcopy-gen/generators"
	"k8s.io/klog/v2"
)

// generateDeepcopyFunctions generates the DeepCopy functions for the given API package paths.
func generateDeepcopyFunctions(path, packagePath, outputBaseFileName, headerFilePath string, verify bool) error {
	wd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get working directory: %w", err)
	}

	// The deepcopy generator cannot import from an absolute path.
	inputPath, err := filepath.Rel(wd, path)
	if err != nil {
		return fmt.Errorf("failed to get relative path for %s: %w", path, err)
	}
	// The path must start with `./` to be considered a relative path
	// by the generator.
	inputPath = fmt.Sprintf(".%s%s", string(os.PathSeparator), inputPath)

	pathPrefix, err := getPathPrefix(wd, inputPath, packagePath)
	if err != nil {
		return fmt.Errorf("failed to get path prefix: %w", err)
	}

	arguments := args.GeneratorArgs{
		InputDirs:                  []string{inputPath},
		OutputFileBaseName:         outputBaseFileName,
		TrimPathPrefix:             pathPrefix,
		GeneratedBuildTag:          "ignore_autogenerated",
		GeneratedByCommentTemplate: "// Code generated by deepcopy-gen. DO NOT EDIT.",
		GoHeaderFilePath:           headerFilePath,
		VerifyOnly:                 verify,
	}

	klog.V(2).Infof("Generating deepcopy into %s", filepath.Join(wd, strings.TrimPrefix(packagePath, pathPrefix)))

	if err := arguments.Execute(
		generators.NameSystems(),
		generators.DefaultNameSystem(),
		generators.Packages,
	); err != nil {
		return fmt.Errorf("error executing deepcopy generator: %w", err)
	}

	return nil
}

// getPathPrefix calculates the pathPrefix that needs to be trimmed from the output file.
// The generator will generate the output file to the current working directory plus the
// package path name.
// This function calculates what is needed to be trimmed from the package path name to
// make sure the output ends up in the correct directory.
// Eg. if the package is github.com/openshift.io/api/machine/v1,
//   - the current working directory is /home/user/go/src, then the path would be
//     github.com/openshift.io/api/machine/v1 and so the output would be the empty string.
//   - the current working directory is /home/user/go/src/github.com/openshift.io/api, then
//     the path would be machine/v1 and so the output would be github.com/openshift.io/api.
func getPathPrefix(wd, path, packagePath string) (string, error) {
	cleanPath := filepath.Clean(path)
	if strings.HasPrefix(cleanPath, "../") {
		return "", errors.New("cannot generate deepcopy functions for a path outside of the working directory")
	}

	if !strings.HasSuffix(packagePath, cleanPath) {
		return "", fmt.Errorf("package path %s does not match with input path %s, expected package path to end with input path", packagePath, cleanPath)
	}

	return strings.TrimSuffix(packagePath, cleanPath), nil
}
